---
title: "Python Scripts and Modules"
teaching: 20
exercises: 2
---

:::::::::::::::::::::::::::::::::::::: questions 

- What is a 'module' in Python? How does this differ from a 'script'?
- What are the benefits of modularising our Python code?

::::::::::::::::::::::::::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::: objectives

- Introduce the example library used in this lesson.
- Understand the limitations of scripts.
- Understand what happens when we `import` something.
- Learn how to convert a simple script into a reusable module.

::::::::::::::::::::::::::::::::::::::::::::::::

## Introduction

Due to its expressiveness, simplicity, and rich ecosystem of external libraries, Python
is well suited for data processing and analysis, and it is commonly used as a scripting
language by scientists and engineers. In this context, a 'script' can be understood as
file containing Python commands that we might run on the command line. This may be a
linear series of simple expressions, but it can also include functions and classes.

For example, the following Python script might be used for epidemiology modelling. It
solves a SIR model, which models the number of Susceptible, Infected, and Recovered
individuals as a pathogen spreads through a population. It isn't necessary to
understand how this works in detail, but the general pattern of the code -- set up
inputs, solve a problem, plot the results -- should be familiar to those working in a
data-oriented field. It uses the popular plotting library [Matplotlib](matplotlib) to
generate a figure.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: instructor

It isn't necessary to dwell on the details of the script. It's only being used
as an example of the sort of script the students might be familiar with.

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

```python
import matplotlib.pyplot as plt

# Inputs
# Total number of susceptible people at the start of an outbreak
pop_size = 8000000
# Average no. of new infections per infected person per day
beta = 0.5
# Inverse of the average number of days taken to recover
gamma = 0.1
# Number of days to run the simulation for
days = 150
# Number of infected people at the start of the simulation
I_0 = 10

# Initialise data
S = [] # Number of susceptible people each day
I = [] # Number of infected people each day
R = [] # Number of recovered people each day
S.append(pop_size - I_0)
I.append(I_0)
R.append(0)

# Solve model
for i in range(days):
    # Get rate of change of S, I, and R
    dS = - beta * S[i] * I[i] / pop_size
    dR = gamma * I[i]
    dI = -(dS + dR)
    # Get values on next day
    S.append(S[i] + dS)
    I.append(I[i] + dI)
    R.append(R[i] + dR)

# Plot results
plt.plot(range(len(S)), S, label="S")
plt.plot(range(len(I)), I, label="I")
plt.plot(range(len(R)), R, label="R")
plt.xlabel("Time /days")
plt.ylabel("Population")
plt.legend()
plt.show()
```

If we save this script to the file `SIR_model_scripy.py`, it can then be run from the
command line as follows:

```bash
$ python3 SIR_model_script.py
```

If everything works as expected, it should produce the following result:

![SIR model results](fig/SIR_model.png){alt="A plot generated by running the SIR model script"}

So far so good, but there are some limitations to this style of coding:

* If the user wants to change the model inputs, they have to open the script file and
  modify some lines of code before running again.
* The raw data is lost each time the code is run, so it can't be used for further
  processing.
* The user must know where the script is stored on their system, navigate to that
  directory, and call it from there.
* If we wish to expand on this functionality in a new script, we must copy the code 
  across to a new file. It would take a lot of extra effort to update both scripts
  every time we wish to adjust the core routine, and this is likely to introduce bugs.

It's important to note that there's nothing strictly _wrong_ with writing scripts in
this way, and it's often a good starting point for any new projects. However, as we
develop our project further, we might find it useful to bundle up the reusable bits 
of our code into a _module_ that we can `import` from other Python programs, just as
we `import`-ed Matplotlib in our own script.

## What is a 'Module'?

A _module_ is simply any file containing Python statements, so, technically, the script
we defined above is already a module. The name of a module is the same as the file name,
only without the `.py` extension. If we were to open a new Python interpretter session
and call the following:

```python
>>> import SIR_model_script
```

then the script would run as if we'd run it from the command line. However, the
variables we defined in the script will be accessible within the _namespace_
`SIR_model_script`:

```python
>>> import SIR_model_script
>>> print(type(SIR_model_script.S))
```
```output
<class 'list'>
```

The current namespace includes all of the objects defined in our interpretter session,
plus all built-in Python functions and types. When we `import` our script, we add the
name of the script to the current namespace, but not the variables defined within it;
those are defined within the _scope_ of `SIR_model_script`, and are only accessible
using the dot operator. If we wanted to bring everything within the script to the
current namespace, but not the module itself, we can instead call:

```python
>>> from SIR_model_script import *
>>> print(type(S))
```
```output
<class 'list'>
```
Alternatively, if we only want a few objects brought into the current namespace, we can
use:

```python
>>> from SIR_model_script import S, I, R
>>> print(type(S), type(I), type(R))
```
```output
<class 'list'> <class 'list'> <class 'list'>
```

::::::::::::::: callout

### The dangers of `from module import *`

Using `from module import *` is considered harmful by many developers, as objects can be
unintentionally overwritten if there are any name clashes between modules. It can also
make it difficult for people reading you code to tell where some functions are classes
have come from. In general, it's better to be explicit about what you're `import`-ing.

:::::::::::::::::::::::

It is also possible to assign an alias to a module name using the `as` keyword:

```python
>>> import SIR_model_script as script
>>> print(type(script.S))
```

Something to note about `import` is that it runs the code found within the module only
the first time it is `import`-ed, so if we were to `import` our script multiple times,
it would only create a plot once.

While we've shown that our script is `import`-able, so far it doesn't seem to provide
many advantages over simply running it on the command line. The next section will
explain what features can make a module more versatile and useful.

::::::::::::::::: challenge

Let's save the following code in the file `my_module.py`:

```python
x = 10
```

Then we open an interpetter and call the following:

```python
>>> import my_module
>>> my_module.x += 5
>>> import my_module
>>> print(my_module.x)
```

What is the result?

::: solution

The result is `15`, as the second import does not run the code in `my_module.py`, and
therefore `my_module.x` is not reset back to `10`.

::::::::::::

:::::::::::::::::::::::::::

## Making a Reusable Module

A good Python module will tend to do the following:

- Define functions, classes and constants that the user might want to use.
- Avoid script-like behaviour, where a lot of computation is performed at the `import`
  stage (although we'll see later in this episode how to have our Python files double
  as reusable modules and runnable scripts).

Ideally, the functions and classes and classes we define should _not_ depend on
variables defined at the module-level scope, except in a few scenarios where it only
makes sense for a single instance of an object to exist.

We can convert the script `SIR_model_script` into a reusable module in a few simple
steps:

- Take note of what data is an _input_, and what is an _output_.
- Bundle the core algorithm into a function that takes our input parameters and
  outputs the results of the SIR simulation.
- Move the plotting parts of the script into another function.

For our SIR model script, the input parameters are as follows:

| Parameter  | Type    | Description                                                    |
| ---------- | ------- | -------------------------------------------------------------- |
| `pop_size` | `int`   | Total number of susceptible people at the start of an outbreak |
| `beta`     | `float` | Average no. of new infections per infected person per day      |
| `gamma`    | `float` | Inverse of the average number of days taken to recover         |
| `days`     | `int`   | Number of days to run the simulation for                       |
| `I_0`      | `int`   | Number of infected people at the start of the simulation       |

And the output data is:

| Parameter  | Type           | Description                            |
| ---------- | -------------- | -------------------------------------- |
| `S`        | `List[float]`  | Number of susceptible people each day  |
| `I`        | `List[float]`  | Number of infected people each day     |
| `R`        | `List[float]`  | Number of recovered people each day    |

We can therefore rewrite the core algorithm as the function `SIR_model`:

```python
def SIR_model(pop_size, beta, gamma, days, I_0):
    """
    Solves a SIR model numerically using a simple integration scheme.

    Parameters
    ----------
    pop_size: int
        Total number of susceptible people at the start of an outbreak.
    beta: float
        Average number of new infections per infected person per day.
    gamma: float
        Inverse of the average number of days taken to recover.
    days: int
        Number of days to run the simulation for.     
    I_0: int
        Number of infected people at the start of the simulation.

    Returns
    -------
    S: List[float]
        Number of susceptible people on each day.
    I: List[float]
        Number of infected people on each day.
    R: List[float]
        Number of recovered people on each day.
    """
    # Initialise data
    S = [] # Number of susceptible people each day
    I = [] # Number of infected people each day
    R = [] # Number of recovered people each day
    S.append(pop_size - I_0)
    I.append(I_0)
    R.append(0)

    # Solve model
    for i in range(days):
        # Get rate of change of S, I, and R
        dS = - beta * S[i] * I[i] / pop_size
        dR = gamma * I[i]
        dI = -(dS + dR)
        # Get values on next day
        S.append(S[i] + dS)
        I.append(I[i] + dI)
        R.append(R[i] + dR)

    return S, I, R
```

Note that we've provided a nice docstring, so that users of our function can understand
how to use it. We can similarly bundle the plotting parts of the script as follows:

```python
import matplotlib.pyplot as plt

def plot_SIR_model(S, I, R):
    """
    Plot the results of a SIR simulation.

    Parameters
    ----------
    S: List[float]
        Number of susceptible people on each day.
    I: List[float]
        Number of infected people on each day.
    R: List[float]
        Number of recovered people on each day.

    Returns
    -------
    None
    """
    plt.plot(range(len(S)), S, label="S")
    plt.plot(range(len(I)), I, label="I")
    plt.plot(range(len(R)), R, label="R")
    plt.xlabel("Time /days")
    plt.ylabel("Population")
    plt.legend()
    plt.show()
```

If we save the two code blocks above to a file called `SIR_model.py`, we can then open
up a Python interpreter and run the following:

```python
>>> from SIR_model import SIR_model, plot_SIR_model
>>> S, I, R = SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
>>> plot_SIR_model(S, I, R)
```

This should give us the same results as when we ran the script earlier, and we can
run the `SIR_model` function with different inputs without needing to change the
input parameters in the file itself. The functions in our script are now therefore
'reusable', and can be integrated in other workflows. However, the script-like
behaviour has been lost:

```bash
$ python3 SIR_model.py
$ # Nothing happens!
```

If we forget how to use these functions, we can view their docstrings using:

```python
>>> import SIR_model
>>> help(SIR_model.SIR_model)
>>> help(SIR_model.plot_SIR_model)
```

In the next section, we'll show how to maintain script-like behaviour, and write
reusable modules in the same file.

## Maintaining Script-Like Functionality

If we wish, we can also maintain the script-like behaviour using the
`if __name__ == "__main__".py` idiom at the bottom of the file `SIR_model.py`:

```python
if __name__ == "__main__":
    S, I, R = SIR_model(
        pop_size=8000000, beta=0.5, gamma=0.1, days=150, I_0=10
    )
    plot_SIR_model(S, I, R)
```

With this is place, we can still run the module as if it were a script:

```bash
$ python3 SIR_model.py
```

However, this section will not run if we `import` the file. Let's break down how this
works:

- Each Python module is automatically assigned a variable `__name__`, and this is
  usually set to the name of the file without the `.py` extension.

```python
>>> import SIR_model
>>> print(SIR_model.__name__)
```
```output
"SIR_model"
```

- The exception to the rule is when we run a Python module as a script. In this case,
  the top-level file instead has its `__name__` variable set to `"__main__"`.

Therefore, the code written under `if __name__ == "__main__"` will run if we use the
module as a script, but not if we `import` the file.

:::::::::::::::::: challenge

If we create the the file `name_test.py`, which contains only the following line:

```python
print(__name__)
```

What happens if we run the following on the command line?

```bash
$ python3 name_test.py
```

::: solution
It prints `"__main__"`
:::

What if instead we open an interpreter and import it?

```python
>>> import name_test
```

::: solution
It prints `"name_test"`
:::

::::::::::::::::::::::::::::

## Managing PYTHONPATH

Our script is now `import`-able, so the `SIR_model` function can be used from any other
Python script, module, or interpretter session. However, we still need to know where
the module is stored on our file system, which can make it difficult to reuse the
functions in a separate project. A simple solution is to set the `PYTHONPATH`
environment variable on our system. On Linux machines, this can be achieved using:

```bash
$ export PYTHONPATH="${PYTHONPATH}:/path/to/my/module/directory"
```

If you want this to be set every time you open a terminal, you can add the line to the
file `~/.bashrc`.

<!-- TODO: include Windows explanation -->

In a later chapter, we will show how to install our own modules using the `pip` package
manager, which gives us much more control over how we integrate our modules into our
Python environments (which may be managed using tools using `venv` or `conda`), and
also allows us to install packages from a remote repository. We'll also show how to
upload our own packages to the remote repository PyPI, and therefore allow others to
download and install our code from the command line!


:::::::::::::::::::::::::::::: keypoints

- Any Python file can be considered a 'module', and can be `import`-ed. This just runs
  the code in the file, and makes the names of any objects in the module accessible
  using dot-notation.
- If we bundle our Python scripts into a collection of functions, we can reuse those
  functions in other modules or in the Python interpretter.
- After turning our scripts into reusable modules, we can maintain script-like behaviour
  using the idiom `if __name__ == "__main__"`.

::::::::::::::::::::::::::::::::::::::::
